/*
* This file is automatically generated from RlzEncode.tt. Edit RlzEncode.tt to automatically update all type-specific variants of these functions.
*/
using System;
using System.Collections.Generic;

namespace UIMFLibrary
{
    /// <summary>
    /// Utilities for encoding intensity using run length encoding
    /// </summary>
    public static class RlzEncode
    {

        /// <summary>
        /// Convert an array of intensities to a zero length encoded array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <returns>
        /// Spectra intensities (output), run-length zero encoded
        /// </returns>
        public static int[] Encode(IReadOnlyList<int> intensities)
        {
            Encode(intensities, out var spectra, out _, out _, out _);

            return spectra;
        }

        /// <summary>
        /// Convert an array of intensities to a zero length encoded array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <param name="spectra">Spectra intensities (output), run-length zero encoded</param>
        /// <param name="tic">TIC (output)</param>
        /// <param name="bpi">Base peak intensity (output)</param>
        /// <param name="indexOfMaxIntensity">Index number of the BPI</param>
        /// <returns>
        /// Number of non-zero data points
        /// </returns>
        public static int Encode(
            IReadOnlyList<int> intensities,
            out int[] spectra,
            out double tic,
            out double bpi,
            out int indexOfMaxIntensity)
        {
            spectra = null;
            tic = 0;
            bpi = 0;
            indexOfMaxIntensity = 0;

            // RLZE - convert 0s to negative multiples as well as calculate TIC and BPI, BPI_MZ
            var zeroCount = 0;
            var rlzeDataList = new List<int>();
            var nonZeroCount = 0;

            // Calculate TIC and BPI while run length zero encoding
            for (var i = 0; i < intensities.Count; i++)
            {
                var intensity = intensities[i];
                if (intensity > 0)
                {
                    // TIC is just the sum of all intensities
                    tic += intensity;
                    if (intensity > bpi)
                    {
                        bpi = intensity;
                        indexOfMaxIntensity = i;
                    }

                    if (zeroCount < 0)
                    {
                        rlzeDataList.Add((int)zeroCount);
                        zeroCount = 0;
                    }

                    rlzeDataList.Add(intensity);
                    nonZeroCount++;
                }
                else
                {
                    if (zeroCount == int.MinValue)
                    {
                        // Too many zeroes; append the current count to rlzeDataList and reset the count to avoid an underflow
                        rlzeDataList.Add((int)zeroCount);
                        zeroCount = 0;
                    }

                    // Always count the zero
                    zeroCount--;
                }
            }
            // We don't care about any zeroes/zeroCount after the last non-zero value; it's better if we don't append them to rlzeDataList.

            spectra = rlzeDataList.ToArray();
            return nonZeroCount;
        }

        /// <summary>
        /// Convert an array of zero length encoded data to a list of bin-intensity pairs
        /// </summary>
        /// <param name="encoded">Spectra intensities, run-length zero encoded</param>
        /// <returns>List of tuples, where Item1 is the bin, and Item2 is the intensity</returns>
        public static List<Tuple<int, int>> Decode(IReadOnlyList<int> encoded)
        {
            var binIntensityTuples = new List<Tuple<int, int>>();
            int previousValue = 0;
            var binIndex = 0;

            for (var i = 0; i < encoded.Count; i++)
            {
                var decodedIntensityValue = encoded[i];

                if (decodedIntensityValue < 0)
                {
                    binIndex += -(int)decodedIntensityValue;
                }
                else if (decodedIntensityValue == 0 && (previousValue.Equals(short.MinValue) || previousValue.Equals(int.MinValue)))
                {
                    // Do nothing: this is to handle an old bug in the run-length zero encoding, that would do a
                    // double-output of a zero (output a zero, and add it to the zero count) if there were enough
                    // consecutive zeroes to hit the underflow limit
                    // Really, the encoding we are using should never output a zero.
                }
                else
                {
                    binIntensityTuples.Add(new Tuple<int, int>(binIndex, decodedIntensityValue));
                    binIndex++;
                }
                previousValue = decodedIntensityValue;
            }
            return binIntensityTuples;
        }

        /// <summary>
        /// Convert an array of intensities to a zero length encoded array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <returns>
        /// Spectra intensities (output), run-length zero encoded
        /// </returns>
        public static short[] Encode(IReadOnlyList<short> intensities)
        {
            Encode(intensities, out var spectra, out _, out _, out _);

            return spectra;
        }

        /// <summary>
        /// Convert an array of intensities to a zero length encoded array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <param name="spectra">Spectra intensities (output), run-length zero encoded</param>
        /// <param name="tic">TIC (output)</param>
        /// <param name="bpi">Base peak intensity (output)</param>
        /// <param name="indexOfMaxIntensity">Index number of the BPI</param>
        /// <returns>
        /// Number of non-zero data points
        /// </returns>
        public static int Encode(
            IReadOnlyList<short> intensities,
            out short[] spectra,
            out double tic,
            out double bpi,
            out int indexOfMaxIntensity)
        {
            spectra = null;
            tic = 0;
            bpi = 0;
            indexOfMaxIntensity = 0;

            // RLZE - convert 0s to negative multiples as well as calculate TIC and BPI, BPI_MZ
            var zeroCount = 0;
            var rlzeDataList = new List<short>();
            var nonZeroCount = 0;

            // Calculate TIC and BPI while run length zero encoding
            for (var i = 0; i < intensities.Count; i++)
            {
                var intensity = intensities[i];
                if (intensity > 0)
                {
                    // TIC is just the sum of all intensities
                    tic += intensity;
                    if (intensity > bpi)
                    {
                        bpi = intensity;
                        indexOfMaxIntensity = i;
                    }

                    if (zeroCount < 0)
                    {
                        rlzeDataList.Add((short)zeroCount);
                        zeroCount = 0;
                    }

                    rlzeDataList.Add(intensity);
                    nonZeroCount++;
                }
                else
                {
                    if (zeroCount == short.MinValue)
                    {
                        // Too many zeroes; append the current count to rlzeDataList and reset the count to avoid an underflow
                        rlzeDataList.Add((short)zeroCount);
                        zeroCount = 0;
                    }

                    // Always count the zero
                    zeroCount--;
                }
            }
            // We don't care about any zeroes/zeroCount after the last non-zero value; it's better if we don't append them to rlzeDataList.

            spectra = rlzeDataList.ToArray();
            return nonZeroCount;
        }

        /// <summary>
        /// Convert an array of zero length encoded data to a list of bin-intensity pairs
        /// </summary>
        /// <param name="encoded">Spectra intensities, run-length zero encoded</param>
        /// <returns>List of tuples, where Item1 is the bin, and Item2 is the intensity</returns>
        public static List<Tuple<int, short>> Decode(IReadOnlyList<short> encoded)
        {
            var binIntensityTuples = new List<Tuple<int, short>>();
            short previousValue = 0;
            var binIndex = 0;

            for (var i = 0; i < encoded.Count; i++)
            {
                var decodedIntensityValue = encoded[i];

                if (decodedIntensityValue < 0)
                {
                    binIndex += -(int)decodedIntensityValue;
                }
                else if (decodedIntensityValue == 0 && (previousValue.Equals(short.MinValue) || previousValue.Equals(short.MinValue)))
                {
                    // Do nothing: this is to handle an old bug in the run-length zero encoding, that would do a
                    // double-output of a zero (output a zero, and add it to the zero count) if there were enough
                    // consecutive zeroes to hit the underflow limit
                    // Really, the encoding we are using should never output a zero.
                }
                else
                {
                    binIntensityTuples.Add(new Tuple<int, short>(binIndex, decodedIntensityValue));
                    binIndex++;
                }
                previousValue = decodedIntensityValue;
            }
            return binIntensityTuples;
        }

        /// <summary>
        /// Convert an array of intensities to a zero length encoded array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <returns>
        /// Spectra intensities (output), run-length zero encoded
        /// </returns>
        public static float[] Encode(IReadOnlyList<float> intensities)
        {
            Encode(intensities, out var spectra, out _, out _, out _);

            return spectra;
        }

        /// <summary>
        /// Convert an array of intensities to a zero length encoded array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <param name="spectra">Spectra intensities (output), run-length zero encoded</param>
        /// <param name="tic">TIC (output)</param>
        /// <param name="bpi">Base peak intensity (output)</param>
        /// <param name="indexOfMaxIntensity">Index number of the BPI</param>
        /// <returns>
        /// Number of non-zero data points
        /// </returns>
        public static int Encode(
            IReadOnlyList<float> intensities,
            out float[] spectra,
            out double tic,
            out double bpi,
            out int indexOfMaxIntensity)
        {
            spectra = null;
            tic = 0;
            bpi = 0;
            indexOfMaxIntensity = 0;

            // RLZE - convert 0s to negative multiples as well as calculate TIC and BPI, BPI_MZ
            var zeroCount = 0;
            var rlzeDataList = new List<float>();
            var nonZeroCount = 0;

            // Calculate TIC and BPI while run length zero encoding
            for (var i = 0; i < intensities.Count; i++)
            {
                var intensity = intensities[i];
                if (intensity > 0)
                {
                    // TIC is just the sum of all intensities
                    tic += intensity;
                    if (intensity > bpi)
                    {
                        bpi = intensity;
                        indexOfMaxIntensity = i;
                    }

                    if (zeroCount < 0)
                    {
                        rlzeDataList.Add((float)zeroCount);
                        zeroCount = 0;
                    }

                    rlzeDataList.Add(intensity);
                    nonZeroCount++;
                }
                else
                {
                    if (zeroCount == short.MinValue)
                    {
                        // Too many zeroes; append the current count to rlzeDataList and reset the count to avoid an underflow
                        rlzeDataList.Add((float)zeroCount);
                        zeroCount = 0;
                    }

                    // Always count the zero
                    zeroCount--;
                }
            }
            // We don't care about any zeroes/zeroCount after the last non-zero value; it's better if we don't append them to rlzeDataList.

            spectra = rlzeDataList.ToArray();
            return nonZeroCount;
        }

        /// <summary>
        /// Convert an array of zero length encoded data to a list of bin-intensity pairs
        /// </summary>
        /// <param name="encoded">Spectra intensities, run-length zero encoded</param>
        /// <returns>List of tuples, where Item1 is the bin, and Item2 is the intensity</returns>
        public static List<Tuple<int, float>> Decode(IReadOnlyList<float> encoded)
        {
            var binIntensityTuples = new List<Tuple<int, float>>();
            float previousValue = 0;
            var binIndex = 0;

            for (var i = 0; i < encoded.Count; i++)
            {
                var decodedIntensityValue = encoded[i];

                if (decodedIntensityValue < 0)
                {
                    binIndex += -(int)decodedIntensityValue;
                }
                else if (decodedIntensityValue == 0 && (previousValue.Equals(short.MinValue) || previousValue.Equals(float.MinValue)))
                {
                    // Do nothing: this is to handle an old bug in the run-length zero encoding, that would do a
                    // double-output of a zero (output a zero, and add it to the zero count) if there were enough
                    // consecutive zeroes to hit the underflow limit
                    // Really, the encoding we are using should never output a zero.
                }
                else
                {
                    binIntensityTuples.Add(new Tuple<int, float>(binIndex, decodedIntensityValue));
                    binIndex++;
                }
                previousValue = decodedIntensityValue;
            }
            return binIntensityTuples;
        }

        /// <summary>
        /// Convert an array of intensities to a zero length encoded array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <returns>
        /// Spectra intensities (output), run-length zero encoded
        /// </returns>
        public static double[] Encode(IReadOnlyList<double> intensities)
        {
            Encode(intensities, out var spectra, out _, out _, out _);

            return spectra;
        }

        /// <summary>
        /// Convert an array of intensities to a zero length encoded array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <param name="spectra">Spectra intensities (output), run-length zero encoded</param>
        /// <param name="tic">TIC (output)</param>
        /// <param name="bpi">Base peak intensity (output)</param>
        /// <param name="indexOfMaxIntensity">Index number of the BPI</param>
        /// <returns>
        /// Number of non-zero data points
        /// </returns>
        public static int Encode(
            IReadOnlyList<double> intensities,
            out double[] spectra,
            out double tic,
            out double bpi,
            out int indexOfMaxIntensity)
        {
            spectra = null;
            tic = 0;
            bpi = 0;
            indexOfMaxIntensity = 0;

            // RLZE - convert 0s to negative multiples as well as calculate TIC and BPI, BPI_MZ
            var zeroCount = 0;
            var rlzeDataList = new List<double>();
            var nonZeroCount = 0;

            // Calculate TIC and BPI while run length zero encoding
            for (var i = 0; i < intensities.Count; i++)
            {
                var intensity = intensities[i];
                if (intensity > 0)
                {
                    // TIC is just the sum of all intensities
                    tic += intensity;
                    if (intensity > bpi)
                    {
                        bpi = intensity;
                        indexOfMaxIntensity = i;
                    }

                    if (zeroCount < 0)
                    {
                        rlzeDataList.Add((double)zeroCount);
                        zeroCount = 0;
                    }

                    rlzeDataList.Add(intensity);
                    nonZeroCount++;
                }
                else
                {
                    if (zeroCount == short.MinValue)
                    {
                        // Too many zeroes; append the current count to rlzeDataList and reset the count to avoid an underflow
                        rlzeDataList.Add((double)zeroCount);
                        zeroCount = 0;
                    }

                    // Always count the zero
                    zeroCount--;
                }
            }
            // We don't care about any zeroes/zeroCount after the last non-zero value; it's better if we don't append them to rlzeDataList.

            spectra = rlzeDataList.ToArray();
            return nonZeroCount;
        }

        /// <summary>
        /// Convert an array of zero length encoded data to a list of bin-intensity pairs
        /// </summary>
        /// <param name="encoded">Spectra intensities, run-length zero encoded</param>
        /// <returns>List of tuples, where Item1 is the bin, and Item2 is the intensity</returns>
        public static List<Tuple<int, double>> Decode(IReadOnlyList<double> encoded)
        {
            var binIntensityTuples = new List<Tuple<int, double>>();
            double previousValue = 0;
            var binIndex = 0;

            for (var i = 0; i < encoded.Count; i++)
            {
                var decodedIntensityValue = encoded[i];

                if (decodedIntensityValue < 0)
                {
                    binIndex += -(int)decodedIntensityValue;
                }
                else if (decodedIntensityValue == 0 && (previousValue.Equals(short.MinValue) || previousValue.Equals(double.MinValue)))
                {
                    // Do nothing: this is to handle an old bug in the run-length zero encoding, that would do a
                    // double-output of a zero (output a zero, and add it to the zero count) if there were enough
                    // consecutive zeroes to hit the underflow limit
                    // Really, the encoding we are using should never output a zero.
                }
                else
                {
                    binIntensityTuples.Add(new Tuple<int, double>(binIndex, decodedIntensityValue));
                    binIndex++;
                }
                previousValue = decodedIntensityValue;
            }
            return binIntensityTuples;
        }
    }
}