/*
* This file is automatically generated from IntensityConverterCLZF.tt. Edit IntensityConverterCLZF.tt to automatically update all type-specific variants of these functions.
*/
using System;
using System.Collections.Generic;
using System.Linq;

// ReSharper disable UnusedMember.Global

namespace UIMFLibrary
{
    /// <summary>
    /// Utilities for encoding intensity using run length encoding and LZF
    /// </summary>
    public static class IntensityConverterCLZF
    {
        // Ignore Spelling: sizeof

        /// <summary>
        /// Convert an array of intensities to a zero run length encoded and LZF compressed byte array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <param name="spectra">Spectra intensity bytes (output)</param>
        /// <param name="tic">TIC (output)</param>
        /// <param name="bpi">Base peak intensity (output)</param>
        /// <param name="indexOfMaxIntensity">Index number of the BPI</param>
        /// <returns>
        /// Number of non-zero data points
        /// </returns>
        public static int Compress(
            IReadOnlyList<int> intensities,
            out byte[] spectra,
            out double tic,
            out double bpi,
            out int indexOfMaxIntensity)
        {
            // Get the size of the data type. Use of sizeof() for primitives is allowed in safe code blocks
            const int dataTypeSize = sizeof(int);

            spectra = null;
            var nonZeroCount = RlzEncode.Encode(intensities, out var runLengthZeroEncodedData, out tic, out bpi, out indexOfMaxIntensity);
            var encodedDataLength = runLengthZeroEncodedData.Length;

            if (encodedDataLength > 0)
            {
                spectra = new byte[encodedDataLength * dataTypeSize];
                Buffer.BlockCopy(runLengthZeroEncodedData, 0, spectra, 0, encodedDataLength * dataTypeSize);
                spectra = CLZF2.Compress(spectra);
            }

            return nonZeroCount;
        }

        /// <summary>
        /// Convert a LZF compressed and zero run length encoded byte array to a list of bin-intensity pairs
        /// </summary>
        /// <param name="compressedBinIntensity">LZF compressed and zero run length encoded byte array</param>
        /// <param name="basePeakIntensity">Highest intensity, and a data-type specifying parameter</param>
        /// <returns>List of tuples, where Item1 is the bin, and Item2 is the intensity</returns>
        public static List<Tuple<int, int>> Decompress(byte[] compressedBinIntensity, out int basePeakIntensity)
        {
            const int dataTypeSize = sizeof(int);
            var output = CLZF2.Decompress(compressedBinIntensity);

            var numReturnedBins = output.Length / dataTypeSize;
            var encodedIntensityValueArray = new int[numReturnedBins];
            Buffer.BlockCopy(output, 0, encodedIntensityValueArray, 0, numReturnedBins * dataTypeSize);

            var data = RlzEncode.Decode(encodedIntensityValueArray);
            basePeakIntensity = data.Max(x => x.Item2);
            return data;
        }

        /// <summary>
        /// Convert an array of intensities to a zero run length encoded and LZF compressed byte array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <param name="spectra">Spectra intensity bytes (output)</param>
        /// <param name="tic">TIC (output)</param>
        /// <param name="bpi">Base peak intensity (output)</param>
        /// <param name="indexOfMaxIntensity">Index number of the BPI</param>
        /// <returns>
        /// Number of non-zero data points
        /// </returns>
        public static int Compress(
            IReadOnlyList<short> intensities,
            out byte[] spectra,
            out double tic,
            out double bpi,
            out int indexOfMaxIntensity)
        {
            // Get the size of the data type. Use of sizeof() for primitives is allowed in safe code blocks
            const int dataTypeSize = sizeof(short);

            spectra = null;
            var nonZeroCount = RlzEncode.Encode(intensities, out var runLengthZeroEncodedData, out tic, out bpi, out indexOfMaxIntensity);
            var encodedDataLength = runLengthZeroEncodedData.Length;

            if (encodedDataLength > 0)
            {
                spectra = new byte[encodedDataLength * dataTypeSize];
                Buffer.BlockCopy(runLengthZeroEncodedData, 0, spectra, 0, encodedDataLength * dataTypeSize);
                spectra = CLZF2.Compress(spectra);
            }

            return nonZeroCount;
        }

        /// <summary>
        /// Convert a LZF compressed and zero run length encoded byte array to a list of bin-intensity pairs
        /// </summary>
        /// <param name="compressedBinIntensity">LZF compressed and zero run length encoded byte array</param>
        /// <param name="basePeakIntensity">Highest intensity, and a data-type specifying parameter</param>
        /// <returns>List of tuples, where Item1 is the bin, and Item2 is the intensity</returns>
        public static List<Tuple<int, short>> Decompress(byte[] compressedBinIntensity, out short basePeakIntensity)
        {
            const int dataTypeSize = sizeof(short);
            var output = CLZF2.Decompress(compressedBinIntensity);

            var numReturnedBins = output.Length / dataTypeSize;
            var encodedIntensityValueArray = new short[numReturnedBins];
            Buffer.BlockCopy(output, 0, encodedIntensityValueArray, 0, numReturnedBins * dataTypeSize);

            var data = RlzEncode.Decode(encodedIntensityValueArray);
            basePeakIntensity = data.Max(x => x.Item2);
            return data;
        }

        /// <summary>
        /// Convert an array of intensities to a zero run length encoded and LZF compressed byte array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <param name="spectra">Spectra intensity bytes (output)</param>
        /// <param name="tic">TIC (output)</param>
        /// <param name="bpi">Base peak intensity (output)</param>
        /// <param name="indexOfMaxIntensity">Index number of the BPI</param>
        /// <returns>
        /// Number of non-zero data points
        /// </returns>
        public static int Compress(
            IReadOnlyList<float> intensities,
            out byte[] spectra,
            out double tic,
            out double bpi,
            out int indexOfMaxIntensity)
        {
            // Get the size of the data type. Use of sizeof() for primitives is allowed in safe code blocks
            const int dataTypeSize = sizeof(float);

            spectra = null;
            var nonZeroCount = RlzEncode.Encode(intensities, out var runLengthZeroEncodedData, out tic, out bpi, out indexOfMaxIntensity);
            var encodedDataLength = runLengthZeroEncodedData.Length;

            if (encodedDataLength > 0)
            {
                spectra = new byte[encodedDataLength * dataTypeSize];
                Buffer.BlockCopy(runLengthZeroEncodedData, 0, spectra, 0, encodedDataLength * dataTypeSize);
                spectra = CLZF2.Compress(spectra);
            }

            return nonZeroCount;
        }

        /// <summary>
        /// Convert a LZF compressed and zero run length encoded byte array to a list of bin-intensity pairs
        /// </summary>
        /// <param name="compressedBinIntensity">LZF compressed and zero run length encoded byte array</param>
        /// <param name="basePeakIntensity">Highest intensity, and a data-type specifying parameter</param>
        /// <returns>List of tuples, where Item1 is the bin, and Item2 is the intensity</returns>
        public static List<Tuple<int, float>> Decompress(byte[] compressedBinIntensity, out float basePeakIntensity)
        {
            const int dataTypeSize = sizeof(float);
            var output = CLZF2.Decompress(compressedBinIntensity);

            var numReturnedBins = output.Length / dataTypeSize;
            var encodedIntensityValueArray = new float[numReturnedBins];
            Buffer.BlockCopy(output, 0, encodedIntensityValueArray, 0, numReturnedBins * dataTypeSize);

            var data = RlzEncode.Decode(encodedIntensityValueArray);
            basePeakIntensity = data.Max(x => x.Item2);
            return data;
        }

        /// <summary>
        /// Convert an array of intensities to a zero run length encoded and LZF compressed byte array
        /// </summary>
        /// <param name="intensities">Array of intensities, including all zeros</param>
        /// <param name="spectra">Spectra intensity bytes (output)</param>
        /// <param name="tic">TIC (output)</param>
        /// <param name="bpi">Base peak intensity (output)</param>
        /// <param name="indexOfMaxIntensity">Index number of the BPI</param>
        /// <returns>
        /// Number of non-zero data points
        /// </returns>
        public static int Compress(
            IReadOnlyList<double> intensities,
            out byte[] spectra,
            out double tic,
            out double bpi,
            out int indexOfMaxIntensity)
        {
            // Get the size of the data type. Use of sizeof() for primitives is allowed in safe code blocks
            const int dataTypeSize = sizeof(double);

            spectra = null;
            var nonZeroCount = RlzEncode.Encode(intensities, out var runLengthZeroEncodedData, out tic, out bpi, out indexOfMaxIntensity);
            var encodedDataLength = runLengthZeroEncodedData.Length;

            if (encodedDataLength > 0)
            {
                spectra = new byte[encodedDataLength * dataTypeSize];
                Buffer.BlockCopy(runLengthZeroEncodedData, 0, spectra, 0, encodedDataLength * dataTypeSize);
                spectra = CLZF2.Compress(spectra);
            }

            return nonZeroCount;
        }

        /// <summary>
        /// Convert a LZF compressed and zero run length encoded byte array to a list of bin-intensity pairs
        /// </summary>
        /// <param name="compressedBinIntensity">LZF compressed and zero run length encoded byte array</param>
        /// <param name="basePeakIntensity">Highest intensity, and a data-type specifying parameter</param>
        /// <returns>List of tuples, where Item1 is the bin, and Item2 is the intensity</returns>
        public static List<Tuple<int, double>> Decompress(byte[] compressedBinIntensity, out double basePeakIntensity)
        {
            const int dataTypeSize = sizeof(double);
            var output = CLZF2.Decompress(compressedBinIntensity);

            var numReturnedBins = output.Length / dataTypeSize;
            var encodedIntensityValueArray = new double[numReturnedBins];
            Buffer.BlockCopy(output, 0, encodedIntensityValueArray, 0, numReturnedBins * dataTypeSize);

            var data = RlzEncode.Decode(encodedIntensityValueArray);
            basePeakIntensity = data.Max(x => x.Item2);
            return data;
        }
    }
}